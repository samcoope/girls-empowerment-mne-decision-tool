// SEM Level definitions for tooltips
const SEM_LEVEL_DEFINITIONS = {
  'Individual': 'Changes in a girl\'s knowledge, skills, attitudes, agency, wellbeing, or behaviours.',
  'Interpersonal': 'Changes in relationships and interactions (family, peers, partners, mentors).',
  'Community': 'Changes in norms, practices, collective safety, and local opportunity structures.',
  'Institutional': 'Changes in policies, services, rules, budgets, and organisational practice.'
};

// State to store user selections and data
let state = {
  methodsData: null,
  categories: [],
  userSelections: {},
  filteredMethods: []
};

// Initialize the application when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', function() {
  loadMethodsData();
  setupEventListeners();
});

// Function to load methods data from JSON
async function loadMethodsData() {
  try {
    // Fetch the methodologies.json file generated by your GitHub workflow
    const response = await fetch('./methodologies.json');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Parse the JSON response
    const jsonData = await response.json();
    
    // Store the data in state
    state.methodsData = jsonData;
    
    // Store the categories for easy access
    state.categories = jsonData.categories;
    
    // Initialize the UI with the loaded data
    initializeUI();
    
    console.log('Methods data loaded successfully:', {
      categories: jsonData.categories.length,
      methods: jsonData.methods.length
    });
    
  } catch (error) {
    console.error('There was a problem loading the methods data:', error);
    
    // Display user-friendly error message
    document.body.innerHTML = `
      <div class="container" style="text-align: center; padding: 50px;">
        <h2>Error Loading Data</h2>
        <p>There was a problem loading the methodology data.</p>
        <p>Please ensure that:</p>
        <ul style="text-align: left; max-width: 600px; margin: 0 auto;">
          <li>The GitHub workflow has run successfully</li>
          <li>The methodologies.json file exists in the repository</li>
          <li>The file is properly formatted JSON</li>
        </ul>
        <p><strong>Error details:</strong> ${error.message}</p>
        <button onclick="location.reload()" class="btn btn-primary" style="margin-top: 20px;">
          Try Again
        </button>
      </div>
    `;
  }
}

// Function to initialize the UI with the loaded data
function initializeUI() {
  // Set up the steps content
  setupStepContent();
  
  // Start at Step 1
  navigateToStep(1);
}

// Function to set up the content for each step
function setupStepContent() {
  // Create category selection steps based on category groups
  const categoryGroups = groupCategoriesByTheme();
  
  // Clear existing step content containers except the first (template)
  const stepContainer = document.querySelector('.container');
  const progressBar = document.querySelector('.progress-bar');
  
  // Remove existing step content divs (except step1 which we'll repurpose)
  document.querySelectorAll('.step-content').forEach((step, index) => {
      if (index > 0) { // Keep the first step as a template
          step.remove();
      }
  });
  
  // Remove existing progress steps (except the first one)
  document.querySelectorAll('.progress-step').forEach((step, index) => {
      if (index > 0) { // Keep the first step as a template
          step.remove();
      }
  });
  
  // Update the first progress step
  const firstProgressStep = document.getElementById('step1-progress');
  firstProgressStep.querySelector('span').textContent = categoryGroups[0].name;
  
  // Add progress steps for each category group
  for (let i = 1; i < categoryGroups.length; i++) {
      const progressStep = document.createElement('div');
      progressStep.className = 'progress-step';
      progressStep.id = `step${i+1}-progress`;
      progressStep.innerHTML = `
          <div class="progress-circle">${i+1}</div>
          <span>${categoryGroups[i].name}</span>
      `;
      progressBar.appendChild(progressStep);
  }
  
  // Add a results step
  const resultsProgressStep = document.createElement('div');
  resultsProgressStep.className = 'progress-step';
  resultsProgressStep.id = `step${categoryGroups.length+1}-progress`;
  resultsProgressStep.innerHTML = `
      <div class="progress-circle">${categoryGroups.length+1}</div>
      <span>Results</span>
  `;
  progressBar.appendChild(resultsProgressStep);
  
  // Update the first step content
  updateStepContent(1, categoryGroups[0]);
  
  // Create step content divs for each category group
  for (let i = 1; i < categoryGroups.length; i++) {
      createStepContent(i+1, categoryGroups[i]);
  }
  
  // Create the results step
  createResultsStep(categoryGroups.length+1);
}

// Function to group categories by theme
function groupCategoriesByTheme() {
  // You can customize this grouping based on your needs
  return [
      {
          name: "Socio-Ecological Model Level",
          categories: [state.categories.find(cat => cat.id === "sem_level")]
      },
      {
          name: "Operating Context",
          categories: [
              state.categories.find(cat => cat.id === "level_of_political_stability"),
              state.categories.find(cat => cat.id === "level_of_cultural_permissiveness"),
              state.categories.find(cat => cat.id === "level_of_political_sensitivity"),
              state.categories.find(cat => cat.id === "participants_access_to_technology_eg_phones_internet")
          ]
      },
      {
          name: "Project Resources",
          categories: [
              state.categories.find(cat => cat.id === "financial_resources_available"),
              state.categories.find(cat => cat.id === "human_resource_skills_available")
          ]
      }
  ];
}

// Function to update the content of the first step
function updateStepContent(stepNumber, group) {
  const stepContent = document.getElementById(`step${stepNumber}`);
  const stepCard = stepContent.querySelector('.card');
  
  // Update the step title
  stepCard.querySelector('h2').textContent = `Select ${group.name}`;
  
  // Clear existing content
  const optionsGrid = document.createElement('div');
  optionsGrid.className = 'options-container';
  
  // Create options for each category in this group
  group.categories.forEach(category => {
      const categorySection = document.createElement('div');
      categorySection.className = 'category-section';

      categorySection.innerHTML = `
          <div class="category-header">
            <h3>${category.name}</h3>
            <button class="select-all-btn" data-category-id="${category.id}">Select All</button>
          </div>
          <div class="checkbox-grid" data-category-id="${category.id}"></div>
      `;
      
      const checkboxGrid = categorySection.querySelector('.checkbox-grid');
      
      // Create checkboxes for each option
      category.options.forEach(option => {
          const checkboxItem = document.createElement('div');
          checkboxItem.className = 'checkbox-item';

          // Add tooltip for SEM level options
          const tooltip = (category.id === 'sem_level' && SEM_LEVEL_DEFINITIONS[option])
            ? `<span class="tooltip">?<span class="tooltiptext">${SEM_LEVEL_DEFINITIONS[option]}</span></span>`
            : '';

          checkboxItem.innerHTML = `
              <label>
                  <input type="checkbox" data-category="${category.id}" data-option="${option}">
                  <span>${option}</span>
                  ${tooltip}
              </label>
          `;

          checkboxGrid.appendChild(checkboxItem);
      });
      
      optionsGrid.appendChild(categorySection);
  });
  
  // Replace existing options grid
  const existingGrid = stepCard.querySelector('.options-container');
  if (existingGrid) {
      stepCard.replaceChild(optionsGrid, existingGrid);
  } else {
      // Replace the paragraph and options-grid with our new content
      const paragraph = stepCard.querySelector('p');
      stepCard.insertBefore(optionsGrid, paragraph.nextSibling);
  }
  
  // Update the buttons
  const buttonsDiv = stepContent.querySelector('.buttons');
  buttonsDiv.innerHTML = '';
  
  // Add reset button
  const resetButton = document.createElement('button');
  resetButton.className = 'secondary';
  resetButton.id = `reset-step${stepNumber}`;
  resetButton.textContent = 'Reset Selections';
  resetButton.addEventListener('click', () => resetStepSelections(stepNumber));
  buttonsDiv.appendChild(resetButton);
  
  // Add back button if not the first step
  if (stepNumber > 1) {
      const backButton = document.createElement('button');
      backButton.className = 'secondary';
      backButton.id = `back-step${stepNumber}`;
      backButton.textContent = 'Back';
      backButton.addEventListener('click', () => navigateToStep(stepNumber - 1));
      buttonsDiv.appendChild(backButton);
  }
  
  // Add next button
  const nextButton = document.createElement('button');
  nextButton.id = `next-step${stepNumber}`;
  nextButton.textContent = 'Next';
  nextButton.addEventListener('click', () => navigateToStep(stepNumber + 1));
  buttonsDiv.appendChild(nextButton);
  
  // Set up event listeners for checkboxes
  stepContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', handleCheckboxChange);
  });
  stepContent.querySelectorAll('.select-all-btn').forEach(button => {
    button.addEventListener('click', handleSelectAllClick);
  });
}

// Function to create a new step content
function createStepContent(stepNumber, group) {
  const container = document.querySelector('.container');
  
  // Create step content div
  const stepContent = document.createElement('div');
  stepContent.className = 'step-content';
  stepContent.id = `step${stepNumber}`;
  
  // Create card
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
      <h2>${group.name}</h2>
      <p>Select the options that match your requirements. Tick all that apply. If you are unsure, please select all</p>
  `;
  
  // Create options container
  const optionsContainer = document.createElement('div');
  optionsContainer.className = 'options-container';
  
  // Create options for each category in this group
  group.categories.forEach(category => {
      const categorySection = document.createElement('div');
      categorySection.className = 'category-section';

      categorySection.innerHTML = `
          <div class="category-header">
              <h3>${category.name}</h3>
              <button class="select-all-btn" data-category-id="${category.id}">Select All</button>
          </div>
          <div class="checkbox-grid" data-category-id="${category.id}"></div>
      `;
      
      const checkboxGrid = categorySection.querySelector('.checkbox-grid');
      
      // Create checkboxes for each option
      category.options.forEach(option => {
          const checkboxItem = document.createElement('div');
          checkboxItem.className = 'checkbox-item';

          // Add tooltip for SEM level options
          const tooltip = (category.id === 'sem_level' && SEM_LEVEL_DEFINITIONS[option])
            ? `<span class="tooltip">?<span class="tooltiptext">${SEM_LEVEL_DEFINITIONS[option]}</span></span>`
            : '';

          checkboxItem.innerHTML = `
              <label>
                  <input type="checkbox" data-category="${category.id}" data-option="${option}">
                  <span>${option}</span>
                  ${tooltip}
              </label>
          `;

          checkboxGrid.appendChild(checkboxItem);
      });
      
      optionsContainer.appendChild(categorySection);
  });
  
  card.appendChild(optionsContainer);
  stepContent.appendChild(card);
  
  // Create buttons
  const buttonsDiv = document.createElement('div');
  buttonsDiv.className = 'buttons';
  
  // Add reset button
  const resetButton = document.createElement('button');
  resetButton.className = 'secondary';
  resetButton.id = `reset-step${stepNumber}`;
  resetButton.textContent = 'Reset Selections';
  resetButton.addEventListener('click', () => resetStepSelections(stepNumber));
  buttonsDiv.appendChild(resetButton);
  
  // Add back button
  const backButton = document.createElement('button');
  backButton.className = 'secondary';
  backButton.id = `back-step${stepNumber}`;
  backButton.textContent = 'Back';
  backButton.addEventListener('click', () => navigateToStep(stepNumber - 1));
  buttonsDiv.appendChild(backButton);
  
  // Add next button
  const nextButton = document.createElement('button');
  nextButton.id = `next-step${stepNumber}`;
  nextButton.textContent = 'Next';
  nextButton.addEventListener('click', () => navigateToStep(stepNumber + 1));
  buttonsDiv.appendChild(nextButton);
  
  stepContent.appendChild(buttonsDiv);
  container.appendChild(stepContent);
  
  // Set up event listeners for checkboxes
  stepContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', handleCheckboxChange);
  });
  stepContent.querySelectorAll('.select-all-btn').forEach(button => {
    button.addEventListener('click', handleSelectAllClick);
  });
}

// Select all functions
// Function to handle select all button clicks
function handleSelectAllClick(event) {
  const button = event.target;
  const categoryId = button.dataset.categoryId;
  const categorySection = button.closest('.category-section');
  const checkboxes = categorySection.querySelectorAll('input[type="checkbox"]');
  
  // Check if all checkboxes are currently selected
  const allSelected = Array.from(checkboxes).every(checkbox => checkbox.checked);
  
  if (allSelected) {
    // Deselect all
    checkboxes.forEach(checkbox => {
      if (checkbox.checked) {
        checkbox.checked = false;
        // Trigger change event to update state
        checkbox.dispatchEvent(new Event('change'));
      }
    });
    button.textContent = 'Select All';
    button.classList.remove('deselect');
  } else {
    // Select all
    checkboxes.forEach(checkbox => {
      if (!checkbox.checked) {
        checkbox.checked = true;
        // Trigger change event to update state
        checkbox.dispatchEvent(new Event('change'));
      }
    });
    button.textContent = 'Deselect All';
    button.classList.add('deselect');
  }
}

// Function to update select all button state
function updateSelectAllButtonState(categoryId) {
  const button = document.querySelector(`.select-all-btn[data-category-id="${categoryId}"]`);
  if (!button) return;
  
  const categorySection = button.closest('.category-section');
  const checkboxes = categorySection.querySelectorAll('input[type="checkbox"]');
  const checkedBoxes = categorySection.querySelectorAll('input[type="checkbox"]:checked');
  
  if (checkedBoxes.length === checkboxes.length && checkboxes.length > 0) {
    button.textContent = 'Deselect All';
    button.classList.add('deselect');
  } else {
    button.textContent = 'Select All';
    button.classList.remove('deselect');
  }
}

// Function to create the results step
function createResultsStep(stepNumber) {
  const container = document.querySelector('.container');
  
  // Create step content div
  const stepContent = document.createElement('div');
  stepContent.className = 'step-content';
  stepContent.id = `step${stepNumber}`;
  
  // Create card
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
      <h2>Matching Methodologies</h2>
      <p>Based on your selections, these methodologies are recommended:</p>
      <div id="results-container" class="results-container">
          <div class="no-results">No matching methodologies found. Try adjusting your selections.</div>
      </div>
  `;
  
  stepContent.appendChild(card);
  
  // Create buttons
  const buttonsDiv = document.createElement('div');
  buttonsDiv.className = 'buttons';
  
  // Add back button
  const backButton = document.createElement('button');
  backButton.className = 'secondary';
  backButton.id = `back-step${stepNumber}`;
  backButton.textContent = 'Back';
  backButton.addEventListener('click', () => navigateToStep(stepNumber - 1));
  buttonsDiv.appendChild(backButton);
  
  // Add start over button
  const startOverButton = document.createElement('button');
  startOverButton.className = 'secondary';
  startOverButton.id = 'start-over';
  startOverButton.textContent = 'Start Over';
  startOverButton.addEventListener('click', () => {
      resetAllSelections();
      navigateToStep(1);
  });
  buttonsDiv.appendChild(startOverButton);
  
  // Add download results button
  const downloadButton = document.createElement('button');
  downloadButton.id = 'download-results';
  downloadButton.textContent = 'Download Results';
  downloadButton.addEventListener('click', downloadResults);
  buttonsDiv.appendChild(downloadButton);
  
  stepContent.appendChild(buttonsDiv);
  container.appendChild(stepContent);
}

// Function to handle checkbox changes
function handleCheckboxChange(event) {
  const checkbox = event.target;
  const category = checkbox.dataset.category;
  const option = checkbox.dataset.option;
  
  // Initialize category in userSelections if it doesn't exist
  if (!state.userSelections[category]) {
      state.userSelections[category] = [];
  }
  
  if (checkbox.checked) {
      // Add the option to the user selections
      if (!state.userSelections[category].includes(option)) {
          state.userSelections[category].push(option);
      }
  } else {
      // Remove the option from the user selections
      state.userSelections[category] = state.userSelections[category].filter(item => item !== option);
      
      // Remove the category if it's empty
      if (state.userSelections[category].length === 0) {
          delete state.userSelections[category];
      }
  }
  
  // Update the filtered methods
  updateFilteredMethods();
  updateSelectAllButtonState(category);
}

function updateFilteredMethods() {
  // Start with all methods
  state.filteredMethods = [...state.methodsData.methods];
  
  // Filter based on user selections
  for (const category in state.userSelections) {
      const selectedOptions = state.userSelections[category];
      
      if (selectedOptions.length > 0) {
          state.filteredMethods = state.filteredMethods.filter(method => {
              // Check if the method has this category
              if (!method.attributes[category]) {
                  return false;
              }
                  // Check if any of the selected options match the method's attributes
                  return selectedOptions.some(option => 

                  method.attributes[category].includes(option)
              );
          });
      }
  }
  
  // Update the results container if we're on the results step
  const resultsContainer = document.getElementById('results-container');
  if (resultsContainer) {
      updateResultsDisplay();
  }
}

// Function to generate context summary narrative
function generateContextSummary() {
  const selections = state.userSelections;
  let narrative = "Based on your selections, we've identified methods suited to ";

  const parts = [];

  // Add SEM level
  if (selections.sem_level && selections.sem_level.length > 0) {
    parts.push(`measuring change at the ${selections.sem_level.join(' and ')} level`);
  }

  // Add context characteristics
  const contextParts = [];

  if (selections.level_of_political_stability && selections.level_of_political_stability.length > 0) {
    contextParts.push(`${selections.level_of_political_stability.join(' or ').toLowerCase()} political conditions`);
  }

  if (selections.level_of_cultural_permissiveness && selections.level_of_cultural_permissiveness.length > 0) {
    contextParts.push(`${selections.level_of_cultural_permissiveness.join(' or ').toLowerCase()} cultural permissiveness`);
  }

  if (selections.level_of_political_sensitivity && selections.level_of_political_sensitivity.length > 0) {
    contextParts.push(`${selections.level_of_political_sensitivity.join(' or ').toLowerCase()} political sensitivity`);
  }

  if (selections.participants_access_to_technology_eg_phones_internet && selections.participants_access_to_technology_eg_phones_internet.length > 0) {
    contextParts.push(`${selections.participants_access_to_technology_eg_phones_internet.join(' or ').toLowerCase()} technology access`);
  }

  if (contextParts.length > 0) {
    parts.push(`in a context with ${contextParts.join(', ')}`);
  }

  // Add resource constraints
  const resourceParts = [];

  if (selections.financial_resources_available && selections.financial_resources_available.length > 0) {
    resourceParts.push(`${selections.financial_resources_available.join(' or ').toLowerCase()} financial resources`);
  }

  if (selections.human_resource_skills_available && selections.human_resource_skills_available.length > 0) {
    resourceParts.push(`${selections.human_resource_skills_available.join(' or ').toLowerCase()} human resource skills`);
  }

  if (resourceParts.length > 0) {
    parts.push(`with ${resourceParts.join(' and ')}`);
  }

  if (parts.length > 0) {
    narrative += parts.join(', ') + '.';
  } else {
    narrative = "We've identified methods that match your requirements.";
  }

  return narrative;
}

// Function to generate decision trace showing filter impact
function generateDecisionTrace() {
  // Start with all methods
  let remaining = [...state.methodsData.methods];
  let trace = [];

  trace.push({
    step: "Starting pool",
    count: remaining.length,
    description: "all available methods"
  });

  // For each selected constraint category
  for (const category in state.userSelections) {
    const selectedOptions = state.userSelections[category];
    const beforeCount = remaining.length;

    // Filter methods
    remaining = remaining.filter(method => {
      if (!method.attributes[category]) {
        return false;
      }
      return selectedOptions.some(option =>
        method.attributes[category].includes(option)
      );
    });

    const removed = beforeCount - remaining.length;

    if (removed > 0) {
      const categoryObj = state.categories.find(c => c.id === category);
      const categoryName = categoryObj ? categoryObj.name : category;

      trace.push({
        step: categoryName,
        removed: removed,
        count: remaining.length,
        description: selectedOptions.join(', ')
      });
    }
  }

  return trace;
}

// Function to group methods by fit quality
function groupMethodsByFit() {
  const groups = {
    bestFit: [],
    goodAlternatives: [],
    stretchOptions: []
  };

  // If no selections, all filtered methods are best fit
  if (Object.keys(state.userSelections).length === 0) {
    groups.bestFit = state.filteredMethods.map(m => ({ method: m, mismatches: [] }));
    return groups;
  }

  state.filteredMethods.forEach(method => {
    let mismatches = [];

    // Check each user selection against method
    for (const category in state.userSelections) {
      const selectedOptions = state.userSelections[category];
      const methodValues = method.attributes[category] || [];

      const hasMatch = selectedOptions.some(option =>
        methodValues.includes(option)
      );

      if (!hasMatch) {
        const categoryObj = state.categories.find(c => c.id === category);
        mismatches.push({
          category: categoryObj ? categoryObj.name : category,
          categoryId: category,
          selected: selectedOptions,
          methodHas: methodValues
        });
      }
    }

    // Categorize by match quality
    if (mismatches.length === 0) {
      groups.bestFit.push({ method: method, mismatches: [] });
    } else if (mismatches.length === 1) {
      groups.goodAlternatives.push({
        method: method,
        mismatches: mismatches
      });
    } else {
      groups.stretchOptions.push({
        method: method,
        mismatches: mismatches
      });
    }
  });

  return groups;
}

// Function to update the results display
function updateResultsDisplay() {
  const resultsContainer = document.getElementById('results-container');
  resultsContainer.innerHTML = '';

  if (state.filteredMethods.length === 0) {
      // No results
      resultsContainer.innerHTML = `
          <div class="no-results">No matching methodologies found. Try adjusting your selections.</div>
      `;
      return;
  }

  // 1. Add context summary if there are user selections
  if (Object.keys(state.userSelections).length > 0) {
    const contextSummary = generateContextSummary();
    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'context-summary';
    summaryDiv.innerHTML = `
      <h3>Your Context</h3>
      <p>${contextSummary}</p>
    `;
    resultsContainer.appendChild(summaryDiv);

    // 2. Add decision trace
    const trace = generateDecisionTrace();
    if (trace.length > 1) { // Only show if there were filters applied
      const traceDiv = document.createElement('div');
      traceDiv.className = 'decision-trace';
      traceDiv.innerHTML = '<h3>How We Narrowed Your Options</h3>';

      const traceList = document.createElement('div');
      traceList.className = 'trace-list';

      trace.forEach((item, index) => {
        const traceItem = document.createElement('div');
        traceItem.className = 'trace-item';

        if (index === 0) {
          traceItem.innerHTML = `
            <div class="trace-step">
              <strong>${item.count}</strong> ${item.description}
            </div>
          `;
        } else {
          traceItem.innerHTML = `
            <div class="trace-arrow">‚Üì</div>
            <div class="trace-step">
              <strong>${item.step}</strong> (${item.description}) ‚Üí <span class="removed-count">${item.removed} removed</span>
              <div class="remaining-count">${item.count} remaining</div>
            </div>
          `;
        }

        traceList.appendChild(traceItem);
      });

      traceDiv.appendChild(traceList);
      resultsContainer.appendChild(traceDiv);
    }
  }

  // 3. Group methods by fit quality
  const groups = groupMethodsByFit();

  // Helper function to create method card
  function createMethodCard(methodData) {
    const method = methodData.method;
    const mismatches = methodData.mismatches || [];

    const methodCard = document.createElement('div');
    methodCard.className = 'methodology-card';

    // Create method header
    const header = document.createElement('div');
    header.className = 'methodology-header';
    header.innerHTML = `<h3>${method.name}</h3>`;

    // Create visible description preview
    const descriptionPreview = document.createElement('div');
    descriptionPreview.className = 'methodology-description-preview';
    descriptionPreview.innerHTML = `<p>${method.description}</p>`;

    // Create method details
    const details = document.createElement('div');
    details.className = 'methodology-details';

    // Add badges if available
    if (method.costTier || method.connectivity || method.type) {
      const badgesDiv = document.createElement('div');
      badgesDiv.className = 'method-badges';

      if (method.costTier) {
        badgesDiv.innerHTML += `<span class="badge cost-badge">üí∞ Cost: ${method.costTier}</span>`;
      }
      if (method.connectivity) {
        badgesDiv.innerHTML += `<span class="badge connectivity-badge">üì∂ Connectivity: ${method.connectivity}</span>`;
      }
      if (method.type) {
        badgesDiv.innerHTML += `<span class="badge type-badge">üéØ Type: ${method.type}</span>`;
      }

      details.appendChild(badgesDiv);
    }

    // Add mismatch info if present
    if (mismatches.length > 0) {
      const mismatchDiv = document.createElement('div');
      mismatchDiv.className = 'mismatch-info';
      mismatchDiv.innerHTML = '<strong>Note:</strong> This method differs in: ';
      const mismatchText = mismatches.map(m => m.category).join(', ');
      mismatchDiv.innerHTML += mismatchText;
      details.appendChild(mismatchDiv);
    }

    // Add links if available
    if (method.link || method.link2) {
      const linksDiv = document.createElement('div');
      linksDiv.className = 'method-links';

      if (method.link) {
        const linkDiv = document.createElement('div');
        linkDiv.className = 'method-link';
        linkDiv.innerHTML = `
          <div class="link-label">üìö Implementation Guide${method.link2 ? ' 1' : ''}:</div>
          <a href="${method.link}" target="_blank" rel="noopener noreferrer">
            ${method.link.length > 60 ? method.link.substring(0, 60) + '...' : method.link}
            <span class="external-icon">‚Üó</span>
          </a>
        `;
        linksDiv.appendChild(linkDiv);
      }

      if (method.link2) {
        const link2Div = document.createElement('div');
        link2Div.className = 'method-link';
        link2Div.innerHTML = `
          <div class="link-label">üìö Implementation Guide 2:</div>
          <a href="${method.link2}" target="_blank" rel="noopener noreferrer">
            ${method.link2.length > 60 ? method.link2.substring(0, 60) + '...' : method.link2}
            <span class="external-icon">‚Üó</span>
          </a>
        `;
        linksDiv.appendChild(link2Div);
      }

      details.appendChild(linksDiv);
    }

    // Create criteria grid
    const criteriaGrid = document.createElement('div');
    criteriaGrid.className = 'criteria-grid';

    // Add key attributes to the criteria grid
    const keyCategories = ['sem_level', 'validity', 'reliability', 'value_for_money', 'resource_requirement'];
    keyCategories.forEach(catId => {
        const category = state.categories.find(c => c.id === catId);
        if (category && method.attributes[catId]) {
            const values = method.attributes[catId].join(', ');
            criteriaGrid.innerHTML += `
                <div class="criteria-item">
                    <div class="criteria-label">${category.name}</div>
                    <div class="criteria-value">${values}</div>
                </div>
            `;
        }
    });

    details.appendChild(criteriaGrid);

    // Add show more button
    const showMoreBtn = document.createElement('button');
    showMoreBtn.className = 'show-more-btn';
    showMoreBtn.textContent = 'Show All Attributes';
    showMoreBtn.addEventListener('click', () => {
        // Toggle between showing key attributes and all attributes
        if (showMoreBtn.textContent === 'Show All Attributes') {
            showMoreBtn.textContent = 'Show Less';
            criteriaGrid.innerHTML = ''; // Clear existing criteria

            // Add all attributes
            for (const catId in method.attributes) {
                const category = state.categories.find(c => c.id === catId);
                if (category) {
                    const values = method.attributes[catId].join(', ');
                    criteriaGrid.innerHTML += `
                        <div class="criteria-item">
                            <div class="criteria-label">${category.name}</div>
                            <div class="criteria-value">${values}</div>
                        </div>
                    `;
                }
            }
        } else {
            showMoreBtn.textContent = 'Show All Attributes';
            criteriaGrid.innerHTML = ''; // Clear existing criteria

            // Add only key attributes
            keyCategories.forEach(catId => {
                const category = state.categories.find(c => c.id === catId);
                if (category && method.attributes[catId]) {
                    const values = method.attributes[catId].join(', ');
                    criteriaGrid.innerHTML += `
                        <div class="criteria-item">
                            <div class="criteria-label">${category.name}</div>
                            <div class="criteria-value">${values}</div>
                        </div>
                    `;
                }
            });
        }
    });

    details.appendChild(showMoreBtn);

    // Add header, description preview, and details to the card
    methodCard.appendChild(header);
    methodCard.appendChild(descriptionPreview);
    methodCard.appendChild(details);

    // Toggle details when clicking on the header
    header.addEventListener('click', function(e) {
        if (details.classList.contains('active')) {
            details.classList.remove('active');
        } else {
            // Close other open details
            document.querySelectorAll('.methodology-details.active').forEach(detail => {
                if (detail !== details) {
                    detail.classList.remove('active');
                }
            });
            details.classList.add('active');
        }
    });

    return methodCard;
  }

  // Display Best Fit section
  if (groups.bestFit.length > 0) {
    const bestFitSection = document.createElement('div');
    bestFitSection.className = 'tier-section best-fit-section';
    bestFitSection.innerHTML = `<h3 class="tier-header">‚≠ê Best Fit (${groups.bestFit.length} ${groups.bestFit.length === 1 ? 'method' : 'methods'})</h3>`;

    groups.bestFit.forEach(methodData => {
      bestFitSection.appendChild(createMethodCard(methodData));
    });

    resultsContainer.appendChild(bestFitSection);
  }

  // Display Good Alternatives section
  if (groups.goodAlternatives.length > 0) {
    const alternativesSection = document.createElement('div');
    alternativesSection.className = 'tier-section alternatives-section';
    alternativesSection.innerHTML = `<h3 class="tier-header">üî∏ Good Alternatives (${groups.goodAlternatives.length} ${groups.goodAlternatives.length === 1 ? 'method' : 'methods'})</h3>`;

    groups.goodAlternatives.forEach(methodData => {
      alternativesSection.appendChild(createMethodCard(methodData));
    });

    resultsContainer.appendChild(alternativesSection);
  }

  // Display Stretch Options section
  if (groups.stretchOptions.length > 0) {
    const stretchSection = document.createElement('div');
    stretchSection.className = 'tier-section stretch-section';
    stretchSection.innerHTML = `<h3 class="tier-header">üöÄ Stretch Options (${groups.stretchOptions.length} ${groups.stretchOptions.length === 1 ? 'method' : 'methods'})</h3>`;

    groups.stretchOptions.forEach(methodData => {
      stretchSection.appendChild(createMethodCard(methodData));
    });

    resultsContainer.appendChild(stretchSection);
  }

  // If no methods in any category (shouldn't happen, but just in case)
  if (groups.bestFit.length === 0 && groups.goodAlternatives.length === 0 && groups.stretchOptions.length === 0) {
    resultsContainer.innerHTML = `
      <div class="no-results">No methods match all constraints. Consider these alternatives:</div>
    `;
  }
}

// Function to navigate between steps
function navigateToStep(stepNumber) {
  // Update filtered methods before showing results
  if (document.getElementById(`step${stepNumber}`).querySelector('#results-container')) {
      updateFilteredMethods();
      updateResultsDisplay();
  }
  
  // Hide all steps
  document.querySelectorAll('.step-content').forEach(step => {
      step.classList.remove('active');
  });
  
  // Reset progress indicators
  document.querySelectorAll('.progress-step').forEach(step => {
      step.classList.remove('active');
      step.classList.remove('completed');
  });
  
  // Show the target step
  document.getElementById(`step${stepNumber}`).classList.add('active');
  
  // Update progress indicators
  for (let i = 1; i <= stepNumber; i++) {
      if (i === stepNumber) {
          document.getElementById(`step${i}-progress`).classList.add('active');
      } else {
          document.getElementById(`step${i}-progress`).classList.add('completed');
      }
  }
}

// Function to reset selections for a specific step
function resetStepSelections(stepNumber) {
  const stepContent = document.getElementById(`step${stepNumber}`);
  
  // Uncheck all checkboxes in this step
  stepContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.checked = false;
      
      // Remove from user selections
      const category = checkbox.dataset.category;
      const option = checkbox.dataset.option;
      
      if (state.userSelections[category]) {
          state.userSelections[category] = state.userSelections[category].filter(item => item !== option);
          
          // Remove the category if it's empty
          if (state.userSelections[category].length === 0) {
              delete state.userSelections[category];
          }
      }
  });
  
  // Update filtered methods
  updateFilteredMethods();
  stepContent.querySelectorAll('.select-all-btn').forEach(button => {
      button.textContent = 'Select All';
      button.classList.remove('deselect');
  });
}

// Function to reset all selections
function resetAllSelections() {
  // Reset user selections
  state.userSelections = {};
  
  // Uncheck all checkboxes
  document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.checked = false;
  });
  
  // Reset filtered methods
  updateFilteredMethods();
}

// Function to download results
function downloadResults() {
  if (state.filteredMethods.length === 0) {
      alert('No methodologies to download. Please adjust your selections.');
      return;
  }
  
  // Create HTML content for the download
  let htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
          <title>M&E Methodology Selection Results - Adolescent Girls Empowerment</title>
          <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
              h1, h2, h3 { color: #00629B; }
              .selection-summary { margin-bottom: 20px; }
              .method-card { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; border-radius: 5px; }
              .method-card h3 { margin-top: 0; color: #00629B; }
              .method-card p { margin: 10px 0; }
              .method-card a { color: #5b92e5; text-decoration: none; word-break: break-all; }
              .method-card a:hover { text-decoration: underline; }
              .attributes-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; margin-top: 15px; }
              .attribute-item { background-color: #f5f5f5; padding: 8px; border-radius: 3px; }
              .attribute-name { font-weight: bold; }
          </style>
      </head>
      <body>
          <h1>M&E Methodology Selection Results - Adolescent Girls Empowerment</h1>
          <div class="selection-summary">
              <h2>Your Selection Criteria</h2>
  `;
  
  // Add user selections
  for (const category in state.userSelections) {
      const categoryObj = state.categories.find(c => c.id === category);
      if (categoryObj) {
        htmlContent += `<p><strong>${categoryObj.name}:</strong> ${state.userSelections[category].join(', ')}</p>`;
      }
  }
  
  // Add methods
  htmlContent += `
          </div>
          <h2>Matching Methodologies (${state.filteredMethods.length})</h2>
  `;
  
  state.filteredMethods.forEach(method => {
      htmlContent += `
          <div class="method-card">
              <h3>${method.name}</h3>
              <p>${method.description}</p>
      `;

      // Add links if available
      if (method.link) {
          htmlContent += `
              <p><strong>üìö Implementation Guide${method.link2 ? ' 1' : ''}:</strong> <a href="${method.link}" target="_blank">${method.link}</a></p>
          `;
      }
      if (method.link2) {
          htmlContent += `
              <p><strong>üìö Implementation Guide 2:</strong> <a href="${method.link2}" target="_blank">${method.link2}</a></p>
          `;
      }

      htmlContent += `<div class="attributes-grid">`;

      // Add all attributes
      for (const catId in method.attributes) {
          const category = state.categories.find(c => c.id === catId);
          if (category) {
              const values = method.attributes[catId].join(', ');
              htmlContent += `
                  <div class="attribute-item">
                      <div class="attribute-name">${category.name}</div>
                      <div class="attribute-value">${values}</div>
                  </div>
              `;
          }
      }

      htmlContent += `
              </div>
          </div>
      `;
  });
  
  htmlContent += `
      </body>
      </html>
  `;
  
  // Create a download link
  const blob = new Blob([htmlContent], { type: 'text/html' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `methodology-selection-results-${new Date().toISOString().split('T')[0]}.html`;
  link.click();
}

// Function to set up event listeners
function setupEventListeners() {
  // Help button
  document.getElementById('help-btn').addEventListener('click', function() {
      document.getElementById('help-modal').style.display = 'block';
  });
  
  // Close help modal
  document.getElementById('close-help').addEventListener('click', function() {
      document.getElementById('help-modal').style.display = 'none';
  });
  
  // Close modals when clicking outside
  window.addEventListener('click', function(event) {
      const helpModal = document.getElementById('help-modal');
      
      if (event.target === helpModal) {
          helpModal.style.display = 'none';
      }
  });
}